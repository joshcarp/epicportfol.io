
google_api:
    @package = "google_api"
    !type CustomHttpPattern:
        @description =:
            | A custom pattern is used for defining custom HTTP verb.
        @source_path = "google/api/http.proto"
        kind <: string:
            @description =:
                | The name of this custom HTTP verb.
            @json_tag = "kind"
            @rpcId = "1"
        path <: string:
            @description =:
                | The path matched by this custom verb.
            @json_tag = "path"
            @rpcId = "2"
    !type Http:
        @description =:
            | Defines the HTTP configuration for an API service. It contains a list of
            | [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method
            | to one or more HTTP REST API methods.
        @source_path = "google/api/http.proto"
        fully_decode_reserved_expansion <: bool:
            @description =:
                | When set to true, URL path parmeters will be fully URI-decoded except in
                | cases of single segment matches in reserved expansion, where "%2F" will be
                | left encoded.
                | The default behavior is to not decode RFC 6570 reserved characters in multi
                | segment matches.
            @json_tag = "fullyDecodeReservedExpansion"
            @rpcId = "2"
        rules <: sequence of HttpRule
    !type HttpRule:
        @description =:
            | `HttpRule` defines the mapping of an RPC method to one or more HTTP
            | REST API methods. The mapping specifies how different portions of the RPC
            | request message are mapped to URL path, URL query parameters, and
            | HTTP request body. The mapping is typically specified as an
            | `google.api.http` annotation on the RPC method,
            | see "google/api/annotations.proto" for details.
            | The mapping consists of a field specifying the path template and
            | method kind.  The path template can refer to fields in the request
            | message, as in the example below which describes a REST GET
            | operation on a resource collection of messages:
            |     service Messaging {
            |       rpc GetMessage(GetMessageRequest) returns (Message) {
            |         option (google.api.http).get = "/v1/messages/{message_id}/{sub.subfield
            |}";
            |       }
            |     }
            |     message GetMessageRequest {
            |       message SubMessage {
            |         string subfield = 1;
            |       }
            |       string message_id = 1; 
            | mapped to the URL
            |       SubMessage sub = 2;    
            | `sub.subfield` is url-mapped
            |     }
            |     message Message {
            |       string text = 1; 
            | content of the resource
            |     }
            | The same http annotation can alternatively be expressed inside the
            | `GRPC API Configuration` YAML file.
            |     http:
            |       rules:
            |         - selector: <proto_package_name>.Messaging.GetMessage
            |           get: /v1/messages/{message_id}/{sub.subfield}
            | This definition enables an automatic, bidrectional mapping of HTTP
            | JSON to RPC. Example:
            | HTTP | RPC
            | -----|-----
            | `GET /v1/messages/123456/foo`  | `GetMessage(message_id: "123456" sub: SubMessa
            |ge(subfield: "foo"))`
            | In general, not only fields but also field paths can be referenced
            | from a path pattern. Fields mapped to the path pattern cannot be
            | repeated and must have a primitive (non-message) type.
            | Any fields in the request message which are not bound by the path
            | pattern automatically become (optional) HTTP query
            | parameters. Assume the following definition of the request message:
            |     service Messaging {
            |       rpc GetMessage(GetMessageRequest) returns (Message) {
            |         option (google.api.http).get = "/v1/messages/{message_id}";
            |       }
            |     }
            |     message GetMessageRequest {
            |       message SubMessage {
            |         string subfield = 1;
            |       }
            |       string message_id = 1; 
            | mapped to the URL
            |       int64 revision = 2;    
            | becomes a parameter
            |       SubMessage sub = 3;    
            | `sub.subfield` becomes a parameter
            |     }
            | This enables a HTTP JSON to RPC mapping as below:
            | HTTP | RPC
            | -----|-----
            | `GET /v1/messages/123456?revision=2&sub.subfield=foo` | `GetMessage(message_id:
            | "123456" revision: 2 sub: SubMessage(subfield: "foo"))`
            | Note that fields which are mapped to HTTP parameters must have a
            | primitive type or a repeated primitive type. Message types are not
            | allowed. In the case of a repeated type, the parameter can be
            | repeated in the URL, as in `...?param=A&param=B`.
            | For HTTP method kinds which allow a request body, the `body` field
            | specifies the mapping. Consider a REST update method on the
            | message resource collection:
            |     service Messaging {
            |       rpc UpdateMessage(UpdateMessageRequest) returns (Message) {
            |         option (google.api.http) = {
            |           put: "/v1/messages/{message_id}"
            |           body: "message"
            |         };
            |       }
            |     }
            |     message UpdateMessageRequest {
            |       string message_id = 1; 
            | mapped to the URL
            |       Message message = 2;   
            | mapped to the body
            |     }
            | The following HTTP JSON to RPC mapping is enabled, where the
            | representation of the JSON in the request body is determined by
            | protos JSON encoding:
            | HTTP | RPC
            | -----|-----
            | `PUT /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id: "12345
            |6" message { text: "Hi!" })`
            | The special name `*` can be used in the body mapping to define that
            | every field not bound by the path template should be mapped to the
            | request body.  This enables the following alternative definition of
            | the update method:
            |     service Messaging {
            |       rpc UpdateMessage(Message) returns (Message) {
            |         option (google.api.http) = {
            |           put: "/v1/messages/{message_id}"
            |           body: "*"
            |         };
            |       }
            |     }
            |     message Message {
            |       string message_id = 1;
            |       string text = 2;
            |     }
            | The following HTTP JSON to RPC mapping is enabled:
            | HTTP | RPC
            | -----|-----
            | `PUT /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id: "12345
            |6" text: "Hi!")`
            | Note that when using `*` in the body mapping, it is not possible to
            | have HTTP parameters, as all fields not bound by the path end in
            | the body. This makes this option more rarely used in practice of
            | defining REST APIs. The common usage of `*` is in custom methods
            | which don't use the URL at all for transferring data.
            | It is possible to define multiple HTTP methods for one RPC by using
            | the `additional_bindings` option. Example:
            |     service Messaging {
            |       rpc GetMessage(GetMessageRequest) returns (Message) {
            |         option (google.api.http) = {
            |           get: "/v1/messages/{message_id}"
            |           additional_bindings {
            |             get: "/v1/users/{user_id}/messages/{message_id}"
            |           }
            |         };
            |       }
            |     }
            |     message GetMessageRequest {
            |       string message_id = 1;
            |       string user_id = 2;
            |     }
            | This enables the following two alternative HTTP JSON to RPC
            | mappings:
            | HTTP | RPC
            | -----|-----
            | `GET /v1/messages/123456` | `GetMessage(message_id: "123456")`
            | `GET /v1/users/me/messages/123456` | `GetMessage(user_id: "me" message_id: "123
            |456")`
            | # Rules for HTTP mapping
            | The rules for mapping HTTP path, query parameters, and body fields
            | to the request message are as follows:
            | 1. The `body` field specifies either `*` or a field path, or is
            |    omitted. If omitted, it indicates there is no HTTP request body.
            | 2. Leaf fields (recursive expansion of nested messages in the
            |    request) can be classified into three types:
            |     (a) Matched in the URL template.
            |     (b) Covered by body (if body is `*`, everything except (a) fields;
            |         else everything under the body field)
            |     (c) All other fields.
            | 3. URL query parameters found in the HTTP request are mapped to (c) fields.
            | 4. Any body sent with an HTTP request can contain only (b) fields.
            | The syntax of the path template is as follows:
            |     Template = "/" Segments [ Verb ] ;
            |     Segments = Segment { "/" Segment } ;
            |     Segment  = "*" | "**" | LITERAL | Variable ;
            |     Variable = "{" FieldPath [ "=" Segments ] "}" ;
            |     FieldPath = IDENT { "." IDENT } ;
            |     Verb     = ":" LITERAL ;
            | The syntax `*` matches a single path segment. The syntax `**` matches zero
            | or more path segments, which must be the last part of the path except the
            | `Verb`. The syntax `LITERAL` matches literal text in the path.
            | The syntax `Variable` matches part of the URL path as specified by its
            | template. A variable template must not contain other variables. If a variable
            | matches a single path segment, its template may be omitted, e.g. `{var}`
            | is equivalent to `{var=*}`.
            | If a variable contains exactly one path segment, such as `"{var}"` or
            | `"{var=*}"`, when such a variable is expanded into a URL path, all characters
            | except `[-_.~0-9a-zA-Z]` are percent-encoded. Such variables show up in the
            | Discovery Document as `{var}`.
            | If a variable contains one or more path segments, such as `"{var=foo/*}"`
            | or `"{var=**}"`, when such a variable is expanded into a URL path, all
            | characters except `[-_.~/0-9a-zA-Z]` are percent-encoded. Such variables
            | show up in the Discovery Document as `{+var}`.
            | NOTE: While the single segment variable matches the semantics of
            | [RFC 6570](https:
            |tools.ietf.org/html/rfc6570) Section 3.2.2
            | Simple String Expansion, the multi segment variable **does not** match
            | RFC 6570 Reserved Expansion. The reason is that the Reserved Expansion
            | does not expand special characters like `?` and `#`, which would lead
            | to invalid URLs.
            | NOTE: the field paths in variables and in the `body` must not refer to
            | repeated fields or map fields.
        @source_path = "google/api/http.proto"
        additional_bindings <: sequence of HttpRule
        body <: string:
            @description =:
                | The name of the request field whose value is mapped to the HTTP body, or
                | `*` for mapping all fields not captured by the path pattern to the HTTP
                | body. NOTE: the referred field must not be a repeated field and must be
                | present at the top-level of request message type.
            @json_tag = "body"
            @rpcId = "7"
        custom <: CustomHttpPattern:
            @description =:
                | The custom pattern is used for specifying an HTTP method that is not
                | included in the `pattern` field, such as HEAD, or "*" to leave the
                | HTTP method unspecified for this rule. The wild-card rule is useful
                | for services that provide content to Web (HTML) clients.
            @json_tag = "custom"
            @rpcId = "8"
        delete <: string:
            @description =:
                | Used for deleting a resource.
            @json_tag = "delete"
            @rpcId = "5"
        get <: string:
            @description =:
                | Used for listing and getting information about resources.
            @json_tag = "get"
            @rpcId = "2"
        patch <: string:
            @description =:
                | Used for updating a resource.
            @json_tag = "patch"
            @rpcId = "6"
        post <: string:
            @description =:
                | Used for creating a resource.
            @json_tag = "post"
            @rpcId = "4"
        put <: string:
            @description =:
                | Used for updating a resource.
            @json_tag = "put"
            @rpcId = "3"
        response_body <: string:
            @description =:
                | Optional. The name of the response field whose value is mapped to the HTTP
                | body of response. Other response fields are ignored. When
                | not set, the response message will be used as HTTP body of response.
            @json_tag = "responseBody"
            @rpcId = "12"
        selector <: string:
            @description =:
                | Selects methods to which this rule applies.
                | Refer to [selector][google.api.DocumentationRule.selector] for syntax details.
            @json_tag = "selector"
            @rpcId = "1"

google_protobuf:
    @package = "google_protobuf"
    !type DescriptorProto:
        @description =:
            | Describes a message type.
        @source_path = "google/protobuf/descriptor.proto"
        enum_type <: sequence of EnumDescriptorProto
        extension <: sequence of FieldDescriptorProto
        extension_range <: sequence of DescriptorProto_ExtensionRange
        field <: sequence of FieldDescriptorProto
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        nested_type <: sequence of DescriptorProto
        oneof_decl <: sequence of OneofDescriptorProto
        options <: MessageOptions:
            @json_tag = "options"
            @rpcId = "7"
        reserved_name <: sequence of string
        reserved_range <: sequence of DescriptorProto_ReservedRange
    !type DescriptorProto_ExtensionRange:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        end <: int:
            @description =:
                | Exclusive.
            @json_tag = "end"
            @rpcId = "2"
        options <: ExtensionRangeOptions:
            @json_tag = "options"
            @rpcId = "3"
        start <: int:
            @description =:
                | Inclusive.
            @json_tag = "start"
            @rpcId = "1"
    !type DescriptorProto_ReservedRange:
        @description =:
            | Range of reserved tag numbers. Reserved tag numbers may not be used by
            | fields or extension ranges in the same message. Reserved ranges may
            | not overlap.
        @source_path = "google/protobuf/descriptor.proto"
        end <: int:
            @description =:
                | Exclusive.
            @json_tag = "end"
            @rpcId = "2"
        start <: int:
            @description =:
                | Inclusive.
            @json_tag = "start"
            @rpcId = "1"
    !type EnumDescriptorProto:
        @description =:
            | Describes an enum type.
        @source_path = "google/protobuf/descriptor.proto"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        options <: EnumOptions:
            @json_tag = "options"
            @rpcId = "3"
        reserved_name <: sequence of string
        reserved_range <: sequence of EnumDescriptorProto_EnumReservedRange
        value <: sequence of EnumValueDescriptorProto
    !type EnumDescriptorProto_EnumReservedRange:
        @description =:
            | Range of reserved numeric values. Reserved values may not be used by
            | entries in the same enum. Reserved ranges may not overlap.
            | Note that this is distinct from DescriptorProto.ReservedRange in that it
            | is inclusive such that it can appropriately represent the entire int32
            | domain.
        @source_path = "google/protobuf/descriptor.proto"
        end <: int:
            @description =:
                | Inclusive.
            @json_tag = "end"
            @rpcId = "2"
        start <: int:
            @description =:
                | Inclusive.
            @json_tag = "start"
            @rpcId = "1"
    !type EnumOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        allow_alias <: bool:
            @description =:
                | Set this option to true to allow mapping different tag names to the same
                | value.
            @json_tag = "allowAlias"
            @rpcId = "2"
        deprecated <: bool:
            @description =:
                | Is this enum deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the enum, or it will be completely ignored; in the very least, this
                | is a formalization for deprecating enums.
            @json_tag = "deprecated"
            @rpcId = "3"
        uninterpreted_option <: sequence of UninterpretedOption
    !type EnumValueDescriptorProto:
        @description =:
            | Describes a value within an enum.
        @source_path = "google/protobuf/descriptor.proto"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        number <: int:
            @json_tag = "number"
            @rpcId = "2"
        options <: EnumValueOptions:
            @json_tag = "options"
            @rpcId = "3"
    !type EnumValueOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        deprecated <: bool:
            @description =:
                | Is this enum value deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the enum value, or it will be completely ignored; in the very least,
                | this is a formalization for deprecating enum values.
            @json_tag = "deprecated"
            @rpcId = "1"
        uninterpreted_option <: sequence of UninterpretedOption
    !type ExtensionRangeOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        uninterpreted_option <: sequence of UninterpretedOption
    !type FieldDescriptorProto:
        @description =:
            | Describes a field within a message.
        @source_path = "google/protobuf/descriptor.proto"
        default_value <: string:
            @description =:
                | For numeric types, contains the original text representation of the value.
                | For booleans, "true" or "false".
                | For strings, contains the default text contents (not escaped in any way).
                | For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
                | TODO(kenton):  Base-64 encode?
            @json_tag = "defaultValue"
            @rpcId = "7"
        extendee <: string:
            @description =:
                | For extensions, this is the name of the type being extended.  It is
                | resolved in the same manner as type_name.
            @json_tag = "extendee"
            @rpcId = "2"
        json_name <: string:
            @description =:
                | JSON name of this field. The value is set by protocol compiler. If the
                | user has set a "json_name" option on this field, that option's value
                | will be used. Otherwise, it's deduced from the field's name by converting
                | it to camelCase.
            @json_tag = "jsonName"
            @rpcId = "10"
        label <: FieldDescriptorProto_Label:
            @json_tag = "label"
            @rpcId = "4"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        number <: int:
            @json_tag = "number"
            @rpcId = "3"
        oneof_index <: int:
            @description =:
                | If set, gives the index of a oneof in the containing type's oneof_decl
                | list.  This field is a member of that oneof.
            @json_tag = "oneofIndex"
            @rpcId = "9"
        options <: FieldOptions:
            @json_tag = "options"
            @rpcId = "8"
        type <: FieldDescriptorProto_Type:
            @description =:
                | If type_name is set, this need not be set.  If both this and type_name
                | are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
            @json_tag = "type"
            @rpcId = "5"
        type_name <: string:
            @description =:
                | For message and enum types, this is the name of the type.  If the name
                | starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
                | rules are used to find the type (i.e. first the nested types within this
                | message are searched, then within the parent, on up to the root
                | namespace).
            @json_tag = "typeName"
            @rpcId = "6"
    !enum FieldDescriptorProto_Label:
        LABEL_OPTIONAL: 1
        LABEL_REPEATED: 3
        LABEL_REQUIRED: 2
    !enum FieldDescriptorProto_Type:
        TYPE_BOOL: 8
        TYPE_BYTES: 12
        TYPE_DOUBLE: 1
        TYPE_ENUM: 14
        TYPE_FIXED32: 7
        TYPE_FIXED64: 6
        TYPE_FLOAT: 2
        TYPE_GROUP: 10
        TYPE_INT32: 5
        TYPE_INT64: 3
        TYPE_MESSAGE: 11
        TYPE_SFIXED32: 15
        TYPE_SFIXED64: 16
        TYPE_SINT32: 17
        TYPE_SINT64: 18
        TYPE_STRING: 9
        TYPE_UINT32: 13
        TYPE_UINT64: 4
    !type FieldOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        ctype <: FieldOptions_CType:
            @description =:
                | The ctype option instructs the C++ code generator to use a different
                | representation of the field than it normally would.  See the specific
                | options below.  This option is not yet implemented in the open source
                | release -- sorry, we'll try to include it in a future version!
            @json_tag = "ctype"
            @rpcId = "1"
        deprecated <: bool:
            @description =:
                | Is this field deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for accessors, or it will be completely ignored; in the very least, this
                | is a formalization for deprecating fields.
            @json_tag = "deprecated"
            @rpcId = "3"
        jstype <: FieldOptions_JSType:
            @description =:
                | The jstype option determines the JavaScript type used for values of the
                | field.  The option is permitted only for 64 bit integral and fixed types
                | (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
                | is represented as JavaScript string, which avoids loss of precision that
                | can happen when a large value is converted to a floating point JavaScript.
                | Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
                | use the JavaScript "number" type.  The behavior of the default option
                | JS_NORMAL is implementation dependent.
                | This option is an enum to permit additional types to be added, e.g.
                | goog.math.Integer.
            @json_tag = "jstype"
            @rpcId = "6"
        lazy <: bool:
            @description =:
                | Should this field be parsed lazily?  Lazy applies only to message-type
                | fields.  It means that when the outer message is initially parsed, the
                | inner message's contents will not be parsed but instead stored in encoded
                | form.  The inner message will actually be parsed when it is first accessed.
                | This is only a hint.  Implementations are free to choose whether to use
                | eager or lazy parsing regardless of the value of this option.  However,
                | setting this option true suggests that the protocol author believes that
                | using lazy parsing on this field is worth the additional bookkeeping
                | overhead typically needed to implement it.
                | This option does not affect the public interface of any generated code;
                | all method signatures remain the same.  Furthermore, thread-safety of the
                | interface is not affected by this option; const methods remain safe to
                | call from multiple threads concurrently, while non-const methods continue
                | to require exclusive access.
                | Note that implementations may choose not to check required fields within
                | a lazy sub-message.  That is, calling IsInitialized() on the outer message
                | may return true even if the inner message has missing required fields.
                | This is necessary because otherwise the inner message would have to be
                | parsed in order to perform the check, defeating the purpose of lazy
                | parsing.  An implementation which chooses not to check required fields
                | must be consistent about it.  That is, for any particular sub-message, the
                | implementation must either *always* check its required fields, or *never*
                | check its required fields, regardless of whether or not the message has
                | been parsed.
            @json_tag = "lazy"
            @rpcId = "5"
        packed <: bool:
            @description =:
                | The packed option can be enabled for repeated primitive fields to enable
                | a more efficient representation on the wire. Rather than repeatedly
                | writing the tag and type for each element, the entire array is encoded as
                | a single length-delimited blob. In proto3, only explicit setting it to
                | false will avoid using packed encoding.
            @json_tag = "packed"
            @rpcId = "2"
        uninterpreted_option <: sequence of UninterpretedOption
        weak <: bool:
            @description =:
                | For Google-internal migration only. Do not use.
            @json_tag = "weak"
            @rpcId = "10"
    !enum FieldOptions_CType:
        CORD: 1
        STRING_: 0
        STRING_PIECE: 2
    !enum FieldOptions_JSType:
        JS_NORMAL: 0
        JS_NUMBER: 2
        JS_STRING: 1
    !type FileDescriptorProto:
        @description =:
            | Describes a complete .proto file.
        @source_path = "google/protobuf/descriptor.proto"
        dependency <: sequence of string
        enum_type <: sequence of EnumDescriptorProto
        extension <: sequence of FieldDescriptorProto
        message_type <: sequence of DescriptorProto
        name <: string:
            @description =:
                | file name, relative to root of source tree
            @json_tag = "name"
            @rpcId = "1"
        options <: FileOptions:
            @json_tag = "options"
            @rpcId = "8"
        package <: string:
            @description =:
                | e.g. "foo", "foo.bar", etc.
            @json_tag = "package"
            @rpcId = "2"
        public_dependency <: sequence of int
        service <: sequence of ServiceDescriptorProto
        source_code_info <: SourceCodeInfo:
            @description =:
                | This field contains optional information about the original source code.
                | You may safely remove this entire field without harming runtime
                | functionality of the descriptors -- the information is needed only by
                | development tools.
            @json_tag = "sourceCodeInfo"
            @rpcId = "9"
        syntax <: string:
            @description =:
                | The syntax of the proto file.
                | The supported values are "proto2" and "proto3".
            @json_tag = "syntax"
            @rpcId = "12"
        weak_dependency <: sequence of int
    !type FileDescriptorSet:
        @description =:
            | The protocol compiler can output a FileDescriptorSet containing the .proto
            | files it parses.
        @source_path = "google/protobuf/descriptor.proto"
        file <: sequence of FileDescriptorProto
    !type FileOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        cc_enable_arenas <: bool:
            @description =:
                | Enables the use of arenas for the proto messages in this file. This applies
                | only to generated classes for C++.
            @json_tag = "ccEnableArenas"
            @rpcId = "31"
        cc_generic_services <: bool:
            @description =:
                | Should generic services be generated in each language?  "Generic" services
                | are not specific to any particular RPC system.  They are generated by the
                | main code generators in each language (without additional plugins).
                | Generic services were the only kind of service generation supported by
                | early versions of google.protobuf.
                | Generic services are now considered deprecated in favor of using plugins
                | that generate code specific to your particular RPC system.  Therefore,
                | these default to false.  Old code which depends on generic services should
                | explicitly set them to true.
            @json_tag = "ccGenericServices"
            @rpcId = "16"
        csharp_namespace <: string:
            @description =:
                | Namespace for generated classes; defaults to the package.
            @json_tag = "csharpNamespace"
            @rpcId = "37"
        deprecated <: bool:
            @description =:
                | Is this file deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for everything in the file, or it will be completely ignored; in the very
                | least, this is a formalization for deprecating files.
            @json_tag = "deprecated"
            @rpcId = "23"
        go_package <: string:
            @description =:
                | Sets the Go package where structs generated from this .proto will be
                | placed. If omitted, the Go package will be derived from the following:
                |   - The basename of the package import path, if provided.
                |   - Otherwise, the package statement in the .proto file, if present.
                |   - Otherwise, the basename of the .proto file, without extension.
            @json_tag = "goPackage"
            @rpcId = "11"
        java_generate_equals_and_hash <: bool:
            @description =:
                | This option does nothing.
            @json_tag = "javaGenerateEqualsAndHash"
            @rpcId = "20"
        java_generic_services <: bool:
            @json_tag = "javaGenericServices"
            @rpcId = "17"
        java_multiple_files <: bool:
            @description =:
                | If set true, then the Java code generator will generate a separate .java
                | file for each top-level message, enum, and service defined in the .proto
                | file.  Thus, these types will *not* be nested inside the outer class
                | named by java_outer_classname.  However, the outer class will still be
                | generated to contain the file's getDescriptor() method as well as any
                | top-level extensions defined in the file.
            @json_tag = "javaMultipleFiles"
            @rpcId = "10"
        java_outer_classname <: string:
            @description =:
                | If set, all the classes from the .proto file are wrapped in a single
                | outer class with the given name.  This applies to both Proto1
                | (equivalent to the old "--one_java_file" option) and Proto2 (where
                | a .proto always translates to a single class, but you may want to
                | explicitly choose the class name).
            @json_tag = "javaOuterClassname"
            @rpcId = "8"
        java_package <: string:
            @description =:
                | Sets the Java package where classes generated from this .proto will be
                | placed.  By default, the proto package is used, but this is often
                | inappropriate because proto packages do not normally start with backwards
                | domain names.
            @json_tag = "javaPackage"
            @rpcId = "1"
        java_string_check_utf8 <: bool:
            @description =:
                | If set true, then the Java2 code generator will generate code that
                | throws an exception whenever an attempt is made to assign a non-UTF-8
                | byte sequence to a string field.
                | Message reflection will do the same.
                | However, an extension field still accepts non-UTF-8 byte sequences.
                | This option has no effect on when used with the lite runtime.
            @json_tag = "javaStringCheckUtf8"
            @rpcId = "27"
        objc_class_prefix <: string:
            @description =:
                | Sets the objective c class prefix which is prepended to all objective c
                | generated classes from this .proto. There is no default.
            @json_tag = "objcClassPrefix"
            @rpcId = "36"
        optimize_for <: FileOptions_OptimizeMode:
            @json_tag = "optimizeFor"
            @rpcId = "9"
        php_class_prefix <: string:
            @description =:
                | Sets the php class prefix which is prepended to all php generated classes
                | from this .proto. Default is empty.
            @json_tag = "phpClassPrefix"
            @rpcId = "40"
        php_generic_services <: bool:
            @json_tag = "phpGenericServices"
            @rpcId = "42"
        php_metadata_namespace <: string:
            @description =:
                | Use this option to change the namespace of php generated metadata classes.
                | Default is empty. When this option is empty, the proto file name will be
                | used for determining the namespace.
            @json_tag = "phpMetadataNamespace"
            @rpcId = "44"
        php_namespace <: string:
            @description =:
                | Use this option to change the namespace of php generated classes. Default
                | is empty. When this option is empty, the package name will be used for
                | determining the namespace.
            @json_tag = "phpNamespace"
            @rpcId = "41"
        py_generic_services <: bool:
            @json_tag = "pyGenericServices"
            @rpcId = "18"
        ruby_package <: string:
            @description =:
                | Use this option to change the package of ruby generated classes. Default
                | is empty. When this option is not set, the package name will be used for
                | determining the ruby package.
            @json_tag = "rubyPackage"
            @rpcId = "45"
        swift_prefix <: string:
            @description =:
                | By default Swift generators will take the proto package and CamelCase it
                | replacing '.' with underscore and use that to prefix the types/symbols
                | defined. When this options is provided, they will use this value instead
                | to prefix the types/symbols defined.
            @json_tag = "swiftPrefix"
            @rpcId = "39"
        uninterpreted_option <: sequence of UninterpretedOption
    !enum FileOptions_OptimizeMode:
        CODE_SIZE: 2
        LITE_RUNTIME: 3
        SPEED: 1
    !type GeneratedCodeInfo:
        @description =:
            | Describes the relationship between generated code and its original source
            | file. A GeneratedCodeInfo message is associated with only one generated
            | source file, but may contain references to different source .proto files.
        @source_path = "google/protobuf/descriptor.proto"
        annotation <: sequence of GeneratedCodeInfo_Annotation
    !type GeneratedCodeInfo_Annotation:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        begin <: int:
            @description =:
                | Identifies the starting offset in bytes in the generated code
                | that relates to the identified object.
            @json_tag = "begin"
            @rpcId = "3"
        end <: int:
            @description =:
                | Identifies the ending offset in bytes in the generated code that
                | relates to the identified offset. The end offset should be one past
                | the last relevant byte (so the length of the text = end - begin).
            @json_tag = "end"
            @rpcId = "4"
        path <: sequence of int
        source_file <: string:
            @description =:
                | Identifies the filesystem path to the original source .proto.
            @json_tag = "sourceFile"
            @rpcId = "2"
    !type MessageOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        deprecated <: bool:
            @description =:
                | Is this message deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the message, or it will be completely ignored; in the very least,
                | this is a formalization for deprecating messages.
            @json_tag = "deprecated"
            @rpcId = "3"
        map_entry <: bool:
            @description =:
                | Whether the message is an automatically generated map entry type for the
                | maps field.
                | For maps fields:
                |     map<KeyType, ValueType> map_field = 1;
                | The parsed descriptor looks like:
                |     message MapFieldEntry {
                |         option map_entry = true;
                |         optional KeyType key = 1;
                |         optional ValueType value = 2;
                |     }
                |     repeated MapFieldEntry map_field = 1;
                | Implementations may choose not to generate the map_entry=true message, but
                | use a native map in the target language to hold the keys and values.
                | The reflection APIs in such implementations still need to work as
                | if the field is a repeated message field.
                | NOTE: Do not set the option in .proto files. Always use the maps syntax
                | instead. The option should only be implicitly set by the proto compiler
                | parser.
            @json_tag = "mapEntry"
            @rpcId = "7"
        message_set_wire_format <: bool:
            @description =:
                | Set true to use the old proto1 MessageSet wire format for extensions.
                | This is provided for backwards-compatibility with the MessageSet wire
                | format.  You should not use this for any other reason:  It's less
                | efficient, has fewer features, and is more complicated.
                | The message must be defined exactly as follows:
                |   message Foo {
                |     option message_set_wire_format = true;
                |     extensions 4 to max;
                |   }
                | Note that the message cannot have any defined fields; MessageSets only
                | have extensions.
                | All extensions of your type must be singular messages; e.g. they cannot
                | be int32s, enums, or repeated messages.
                | Because this is an option, the above two restrictions are not enforced by
                | the protocol compiler.
            @json_tag = "messageSetWireFormat"
            @rpcId = "1"
        no_standard_descriptor_accessor <: bool:
            @description =:
                | Disables the generation of the standard "descriptor()" accessor, which can
                | conflict with a field of the same name.  This is meant to make migration
                | from proto1 easier; new code should avoid fields named "descriptor".
            @json_tag = "noStandardDescriptorAccessor"
            @rpcId = "2"
        uninterpreted_option <: sequence of UninterpretedOption
    !type MethodDescriptorProto:
        @description =:
            | Describes a method of a service.
        @source_path = "google/protobuf/descriptor.proto"
        client_streaming <: bool:
            @description =:
                | Identifies if client streams multiple client messages
            @json_tag = "clientStreaming"
            @rpcId = "5"
        input_type <: string:
            @description =:
                | Input and output type names.  These are resolved in the same way as
                | FieldDescriptorProto.type_name, but must refer to a message type.
            @json_tag = "inputType"
            @rpcId = "2"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        options <: MethodOptions:
            @json_tag = "options"
            @rpcId = "4"
        output_type <: string:
            @json_tag = "outputType"
            @rpcId = "3"
        server_streaming <: bool:
            @description =:
                | Identifies if server streams multiple server messages
            @json_tag = "serverStreaming"
            @rpcId = "6"
    !type MethodOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        deprecated <: bool:
            @description =:
                | Is this method deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the method, or it will be completely ignored; in the very least,
                | this is a formalization for deprecating methods.
            @json_tag = "deprecated"
            @rpcId = "33"
        idempotency_level <: MethodOptions_IdempotencyLevel:
            @json_tag = "idempotencyLevel"
            @rpcId = "34"
        uninterpreted_option <: sequence of UninterpretedOption
    !enum MethodOptions_IdempotencyLevel:
        IDEMPOTENCY_UNKNOWN: 0
        IDEMPOTENT: 2
        NO_SIDE_EFFECTS: 1
    !type OneofDescriptorProto:
        @description =:
            | Describes a oneof.
        @source_path = "google/protobuf/descriptor.proto"
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        options <: OneofOptions:
            @json_tag = "options"
            @rpcId = "2"
    !type OneofOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        uninterpreted_option <: sequence of UninterpretedOption
    !type ServiceDescriptorProto:
        @description =:
            | Describes a service.
        @source_path = "google/protobuf/descriptor.proto"
        method <: sequence of MethodDescriptorProto
        name <: string:
            @json_tag = "name"
            @rpcId = "1"
        options <: ServiceOptions:
            @json_tag = "options"
            @rpcId = "3"
    !type ServiceOptions:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        deprecated <: bool:
            @description =:
                | Is this service deprecated?
                | Depending on the target platform, this can emit Deprecated annotations
                | for the service, or it will be completely ignored; in the very least,
                | this is a formalization for deprecating services.
            @json_tag = "deprecated"
            @rpcId = "33"
        uninterpreted_option <: sequence of UninterpretedOption
    !type SourceCodeInfo:
        @description =:
            | Encapsulates information about the original source file from which a
            | FileDescriptorProto was generated.
        @source_path = "google/protobuf/descriptor.proto"
        location <: sequence of SourceCodeInfo_Location
    !type SourceCodeInfo_Location:
        @description = ""
        @source_path = "google/protobuf/descriptor.proto"
        leading_comments <: string:
            @description =:
                | If this SourceCodeInfo represents a complete declaration, these are any
                | comments appearing before and after the declaration which appear to be
                | attached to the declaration.
                | A series of line comments appearing on consecutive lines, with no other
                | tokens appearing on those lines, will be treated as a single comment.
                | leading_detached_comments will keep paragraphs of comments that appear
                | before (but not connected to) the current element. Each paragraph,
                | separated by empty lines, will be one comment element in the repeated
                | field.
                | Only the comment content is provided; comment markers (e.g. 
                |) are
                | stripped out.  For block comments, leading whitespace and an asterisk
                | will be stripped from the beginning of each line other than the first.
                | Newlines are included in the output.
                | Examples:
                |   optional int32 foo = 1;  
                | Comment attached to foo.
                |   
                | Comment attached to bar.
                |   optional int32 bar = 2;
                |   optional string baz = 3;
                |   
                | Comment attached to baz.
                |   
                | Another line attached to baz.
                |   
                | Comment attached to qux.
                |   
                |   
                | Another line attached to qux.
                |   optional double qux = 4;
                |   
                | Detached comment for corge. This is not leading or trailing comments
                |   
                | to qux or corge because there are blank lines separating it from
                |   
                | both.
                |   
                | Detached comment for corge paragraph 2.
                |   optional string corge = 5;
                |   /* Block comment attached
                |    * to corge.  Leading asterisks
                |    * will be removed. */
                |   /* Block comment attached to
                |    * grault. */
                |   optional int32 grault = 6;
                |   
                | ignored detached comments.
            @json_tag = "leadingComments"
            @rpcId = "3"
        leading_detached_comments <: sequence of string
        path <: sequence of int
        span <: sequence of int
        trailing_comments <: string:
            @json_tag = "trailingComments"
            @rpcId = "4"
    !type UninterpretedOption:
        @description =:
            | A message representing a option the parser does not recognize. This only
            | appears in options protos created by the compiler::Parser class.
            | DescriptorPool resolves these when building Descriptor objects. Therefore,
            | options protos in descriptor objects (e.g. returned by Descriptor::options(),
            | or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
            | in them.
        @source_path = "google/protobuf/descriptor.proto"
        aggregate_value <: string:
            @json_tag = "aggregateValue"
            @rpcId = "8"
        double_value <: float:
            @json_tag = "doubleValue"
            @rpcId = "6"
        identifier_value <: string:
            @description =:
                | The value of the uninterpreted option, in whatever type the tokenizer
                | identified it as during parsing. Exactly one of these should be set.
            @json_tag = "identifierValue"
            @rpcId = "3"
        name <: sequence of UninterpretedOption_NamePart
        negative_int_value <: int:
            @json_tag = "negativeIntValue"
            @rpcId = "5"
        positive_int_value <: int:
            @json_tag = "positiveIntValue"
            @rpcId = "4"
        string_value <: bytes:
            @json_tag = "stringValue"
            @rpcId = "7"
    !type UninterpretedOption_NamePart:
        @description =:
            | The name of the uninterpreted option.  Each string represents a segment in
            | a dot-separated name.  is_extension is true iff a segment represents an
            | extension (denoted with parentheses in options specs in .proto files).
            | E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
            | "foo.(bar.baz).qux".
        @source_path = "google/protobuf/descriptor.proto"
        is_extension <: bool:
            @json_tag = "isExtension"
            @rpcId = "2"
        name_part <: string:
            @json_tag = "namePart"
            @rpcId = "1"

itProject[~gRPC]:
    @description = ""
    @package = "itproject"
    @source_path = "api.proto"
    Hello(input <: itproject.HelloRequest)[~gRPC]:
        @description = ""
        @source_path = "api.proto"
        return ok <: itproject.HelloResponse

itproject:
    @package = "itproject"
    !type HelloRequest:
        @description = ""
        @source_path = "api.proto"
        Content <: string:
            @json_tag = "Content"
            @rpcId = "1"
    !type HelloResponse:
        @description = ""
        @source_path = "api.proto"
        Content <: string:
            @json_tag = "Content"
            @rpcId = "1"

